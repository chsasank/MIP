tic
load('assignmentImageReconstructionPhantom.mat')

% imageKspaceData=imageKspaceData(1:2:end,1:2:end);
% imageKspaceMask=imageKspaceMask(1:2:end,1:2:end);
% imageNoiseless=imageNoiseless(1:2:end,1:2:end);

imageNoisy=ifft2(imageKspaceData);


stepSize=0.001;
alpha=0.5;

prevIm=imageNoisy;
mat1=prevIm-circshift(prevIm,1);
mat2=prevIm-circshift(prevIm,-1);
mat3=prevIm-circshift(prevIm',1)';
mat4=prevIm-circshift(prevIm',-1)';
V=abs(mat1).^2+abs(mat2).^2+abs(mat3).^2+abs(mat4).^2;% Potential Function

mat=imageKspaceData-imageKspaceMask*fft2(prevIm);%likelihood
mat=abs(mat).^2;
mat=(1-alpha)*mat+alpha*V;

negLogPrev=sum(sum(mat));
gradient=2*(1-alpha)*(ifft2(imageKspaceMask'*imageKspaceMask*fft2(prevIm))-ifft2(imageKspaceMask'*imageKspaceData))+alpha*real(prevIm);

flag=true;

while(flag)
    
    currentIm=prevIm-stepSize*gradient;
    mat1=currentIm-circshift(currentIm,1);
    mat2=currentIm-circshift(currentIm,-1);
    mat3=currentIm-circshift(currentIm',1)';
    mat4=currentIm-circshift(currentIm',-1)';
    V=abs(mat1).^2+abs(mat2).^2+abs(mat3).^2+abs(mat4).^2;
    mat=imageKspaceData-imageKspaceMask*fft2(currentIm);
    mat=abs(mat).^2;
    mat=(1-alpha)*mat+alpha*V;
    negLogCurr=sum(sum(mat));
    
    
    if abs(negLogPrev-negLogCurr)/negLogPrev < 0.01
        flag=false;
        break;
    elseif negLogCurr>negLogPrev
        stepSize=stepSize*0.5;
    elseif negLogCurr<negLogPrev
        stepSize=stepSize*1.1;
    end
    gradient=2*(1-alpha)*(ifft2(imageKspaceMask'*imageKspaceMask*fft2(currentIm))-ifft2(imageKspaceMask'*imageKspaceData))+alpha*real(currentIm);
    prevIm=currentIm;
    negLogPrev=negLogCurr;
end


toc
